<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de cat√©gorisation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }
        .test-fail {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        h1 {
            color: #333;
        }
        h2 {
            color: #555;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .summary {
            font-size: 1.2em;
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .summary.pass {
            background: #d4edda;
            color: #155724;
        }
        .summary.fail {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>üß™ Test de Cat√©gorisation - Correctif Faux Positifs</h1>

    <div id="results"></div>

    <script>
        // Copie des constantes et fonctions depuis index.html
        const DEFAULT_CATEGORIES = {
            'fruits': { id: 'default_fruits', icon: 'üçé', color: 'var(--cat-fruits)', priority: 2, keywords: ['pomme', 'banane', 'orange', 'poire', 'fraise', 'raisin', 'kiwi', 'mangue', 'ananas', 'melon', 'past√®que', 'citron', 'pamplemousse', 'abricot', 'p√™che', 'prune', 'cerise', 'framboise', 'myrtille', 'cl√©mentine', 'mandarine', 'fruit', 'nectarine', 'grenade', 'figue', 'litchi', 'papaye', 'fruit de la passion', 'noix de coco', 'avocat', 'cassis', 'groseille', 'm√ªre'] },
            'legumes': { id: 'default_legumes', icon: 'ü•¨', color: 'var(--cat-legumes)', priority: 2, keywords: ['tomate', 'salade', 'carotte', 'courgette', 'poivron', 'oignon', 'ail', 'pomme de terre', 'haricot', 'petit pois', 'brocoli', 'chou', 'aubergine', 'concombre', 'radis', 'navet', 'poireau', '√©pinard', 'champignon', 'l√©gume', '√©chalote', 'c√©leri', 'laitue', 'm√¢che', 'endive', 'artichaut', 'asperge', 'betterave', 'chou-fleur', 'fenouil', 'patate', 'citrouille', 'courge', 'potiron', 'ma√Øs', 'persil', 'basilic', 'coriandre', 'ciboulette'] },
            'boissons': { id: 'default_boissons', icon: 'ü•§', color: 'var(--cat-boissons)', priority: 1, keywords: ['eau', 'jus', 'soda', 'vin', 'bi√®re', 'coca', 'limonade', 'sirop', 'boisson', 'pepsi', 'fanta', 'sprite', 'orangina', 'perrier', 'vittel', 'evian', 'badoit', 'th√© glac√©', 'ice tea', 'nectar', 'smoothie', 'champagne', 'ros√©', 'rouge', 'blanc', 'cidre', 'pastis', 'whisky', 'rhum', 'vodka', 'gin', 'ap√©ritif', 'digestif', 'liqueur'] },
            'boulangerie': { id: 'default_boulangerie', icon: 'ü•ñ', color: 'var(--cat-boulangerie)', priority: 2, keywords: ['pain', 'baguette', 'croissant', 'brioche', 'g√¢teau', 'tarte', 'viennoiserie', 'pain de mie', 'pain complet', 'pain de campagne', 'ficelle', 'pain au chocolat', 'chocolatine', 'chausson aux pommes', '√©clair', 'religieuse', 'mille-feuille', 'chouquette', 'macaron', 'financier', 'madeleine', 'cookie', 'brownie', 'muffin', 'donut', 'cupcake'] },
            'epicerie': { id: 'default_epicerie', icon: 'üõçÔ∏è', color: 'var(--cat-epicerie)', priority: 2, keywords: ['riz', 'p√¢tes', 'farine', 'sucre', 'sel', 'poivre', 'huile', 'vinaigre', 'conserve', 'sauce', 'c√©r√©ales', 'caf√©', 'th√©', 'chocolat', 'confiture', 'miel', 'biscuit', 'spaghetti', 'macaroni', 'coquillette', 'tagliatelle', 'nouille', 'semoule', 'quinoa', 'boulgour', 'lentille', 'pois chiche', 'haricot sec', 'levure', 'chapelure', 'ma√Øzena', 'pur√©e', 'ketchup', 'mayonnaise', 'moutarde', 'cornichon', 'olive', 'c√¢pre', '√©pice', 'herbe', 'bouillon cube', 'soupe', 'barre de c√©r√©ale', 'compote', 'nutella'] },
            'bricolage': { id: 'default_bricolage', icon: 'üî®', color: 'var(--cat-bricolage)', priority: 2, keywords: ['marteau', 'tournevis', 'vis', 'clou', 'scie', 'perceuse', 'pince', 'cl√©', 'tenaille', 'niveau', 'm√®tre', 'lime', 'rabot', 'serre-joint', 'cl√© √† molette', 'pinceau', 'rouleau', 'peinture', 'vernis', 'planche', 'bois', 'ciment', 'ruban adh√©sif', 'c√¢ble', 'fil √©lectrique', 'ampoule', 'douille', 'interrupteur', 'chevilles', '√©crou', 'boulon', 'rondelle'] },
            'autre': { id: 'default_autre', icon: 'üì¶', color: 'var(--cat-autre)', priority: 0, keywords: [] }
        };

        let state = {
            categories: DEFAULT_CATEGORIES
        };

        // Fonction de normalisation
        function normalizeText(text) {
            return text.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .trim();
        }

        // Fonction de tokenisation
        function tokenize(text) {
            return normalizeText(text)
                .split(/[\s\-''_,;:.!?()[\]{}]+/)
                .filter(token => token.length > 0);
        }

        // Fonction pour obtenir les variantes d'un mot (singulier/pluriel)
        function getWordVariants(word) {
            const variants = [word];

            // Si le mot se termine par 's' et fait plus de 3 caract√®res, ajouter la forme sans 's'
            if (word.length > 3 && word.endsWith('s') && !word.endsWith('ss')) {
                variants.push(word.slice(0, -1));
            }

            // Si le mot se termine par 'x' et fait plus de 3 caract√®res, essayer la forme sans 'x'
            if (word.length > 3 && word.endsWith('x')) {
                variants.push(word.slice(0, -1));
            }

            // Ajouter la forme plurielle si elle n'existe pas d√©j√†
            if (!word.endsWith('s') && !word.endsWith('x')) {
                variants.push(word + 's');
                // Certains mots prennent 'x' au pluriel (g√¢teau ‚Üí g√¢teaux)
                if (word.endsWith('au') || word.endsWith('eau')) {
                    variants.push(word + 'x');
                }
            }

            return variants;
        }

        // V√©rifie si un mot correspond exactement √† un token du texte
        function matchesWord(normalizedItemTokens, normalizedKeyword) {
            const keywordTokens = tokenize(normalizedKeyword);

            if (keywordTokens.length === 1) {
                // Mot simple : doit matcher exactement un token (ou ses variantes pluriel/singulier)
                const keywordVariants = getWordVariants(keywordTokens[0]);

                for (const itemToken of normalizedItemTokens) {
                    const itemVariants = getWordVariants(itemToken);

                    // V√©rifier si une variante du mot-cl√© correspond √† une variante de l'item
                    for (const keywordVariant of keywordVariants) {
                        if (itemVariants.includes(keywordVariant)) {
                            return true;
                        }
                    }
                }
                return false;
            } else {
                // Expression multi-mots : cherche une correspondance cons√©cutive avec support des variantes
                for (let i = 0; i <= normalizedItemTokens.length - keywordTokens.length; i++) {
                    let match = true;
                    for (let j = 0; j < keywordTokens.length; j++) {
                        const itemVariants = getWordVariants(normalizedItemTokens[i + j]);
                        const keywordVariants = getWordVariants(keywordTokens[j]);

                        let tokenMatch = false;
                        for (const keywordVariant of keywordVariants) {
                            if (itemVariants.includes(keywordVariant)) {
                                tokenMatch = true;
                                break;
                            }
                        }

                        if (!tokenMatch) {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
                return false;
            }
        }

        function getCategory(itemName) {
            const normalizedItemTokens = tokenize(itemName);
            const matches = [];

            for (const [category, data] of Object.entries(state.categories)) {
                if (!data.keywords || data.keywords.length === 0) continue;

                for (const keyword of data.keywords) {
                    if (matchesWord(normalizedItemTokens, keyword)) {
                        matches.push({
                            category: category,
                            id: data.id || category,
                            priority: data.priority || 0,
                            keyword: keyword
                        });
                        break;
                    }
                }
            }

            if (matches.length > 0) {
                matches.sort((a, b) => b.priority - a.priority);
                return matches[0].id;
            }

            return state.categories['autre']?.id || 'default_autre';
        }

        function getCategoryName(categoryId) {
            for (const [key, data] of Object.entries(state.categories)) {
                if (data.id === categoryId) {
                    return key;
                }
            }
            return 'autre';
        }

        // Tests
        const testCases = {
            "Cas positifs - Doivent √™tre cat√©goris√©s correctement": [
                { item: "eau", expected: "boissons", description: "Le mot 'eau' seul doit √™tre cat√©goris√© en Boissons" },
                { item: "Eau", expected: "boissons", description: "Test de casse : 'Eau' doit √™tre cat√©goris√© en Boissons" },
                { item: "eau min√©rale", expected: "boissons", description: "'eau min√©rale' doit √™tre cat√©goris√© en Boissons" },
                { item: "marteau", expected: "bricolage", description: "'marteau' doit √™tre cat√©goris√© en Bricolage" },
                { item: "g√¢teau", expected: "boulangerie", description: "'g√¢teau' doit √™tre cat√©goris√© en Boulangerie" },
                { item: "g√¢teaux", expected: "boulangerie", description: "'g√¢teaux' (pluriel) doit √™tre cat√©goris√© en Boulangerie" },
                { item: "gateau", expected: "boulangerie", description: "'gateau' (sans accent) doit √™tre cat√©goris√© en Boulangerie" },
                { item: "th√©", expected: "epicerie", description: "'th√©' doit √™tre cat√©goris√© en √âpicerie" },
                { item: "caf√©", expected: "epicerie", description: "'caf√©' doit √™tre cat√©goris√© en √âpicerie" },
                { item: "jus", expected: "boissons", description: "'jus' doit √™tre cat√©goris√© en Boissons" },
                { item: "vin", expected: "boissons", description: "'vin' doit √™tre cat√©goris√© en Boissons" }
            ],
            "Faux positifs - NE DOIVENT PAS √™tre cat√©goris√©s en Boissons": [
                { item: "rideau", notExpected: "boissons", description: "'rideau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "ch√¢teau", notExpected: "boissons", description: "'ch√¢teau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "couteau", notExpected: "boissons", description: "'couteau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "bureau", notExpected: "boissons", description: "'bureau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "seau", notExpected: "boissons", description: "'seau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "bateau", notExpected: "boissons", description: "'bateau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "peau", notExpected: "boissons", description: "'peau' contient 'eau' mais NE doit PAS √™tre en Boissons" },
                { item: "beaut√©", notExpected: "boissons", description: "'beaut√©' contient 'eau' mais NE doit PAS √™tre en Boissons" }
            ],
            "Variantes et pluriels": [
                { item: "pommes", expected: "fruits", description: "'pommes' (pluriel) doit √™tre cat√©goris√© en Fruits" },
                { item: "TOMATE", expected: "legumes", description: "'TOMATE' (majuscules) doit √™tre cat√©goris√© en L√©gumes" },
                { item: "Caf√©", expected: "epicerie", description: "'Caf√©' (casse mixte) doit √™tre cat√©goris√© en √âpicerie" }
            ]
        };

        // Ex√©cuter les tests
        let totalTests = 0;
        let passedTests = 0;
        let results = document.getElementById('results');

        for (const [sectionName, tests] of Object.entries(testCases)) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h2>${sectionName}</h2>`;

            tests.forEach(test => {
                totalTests++;
                const categoryId = getCategory(test.item);
                const categoryName = getCategoryName(categoryId);

                let passed = false;
                let message = '';

                if (test.expected) {
                    passed = categoryName === test.expected;
                    message = `"${test.item}" ‚Üí ${categoryName} ${passed ? '‚úì' : '‚úó (attendu: ' + test.expected + ')'}`;
                } else if (test.notExpected) {
                    passed = categoryName !== test.notExpected;
                    message = `"${test.item}" ‚Üí ${categoryName} ${passed ? '‚úì' : '‚úó (ne devrait PAS √™tre: ' + test.notExpected + ')'}`;
                }

                if (passed) passedTests++;

                const testItem = document.createElement('div');
                testItem.className = `test-item ${passed ? 'test-pass' : 'test-fail'}`;
                testItem.innerHTML = `
                    <strong>${message}</strong><br>
                    <small>${test.description}</small>
                `;
                section.appendChild(testItem);
            });

            results.appendChild(section);
        }

        // R√©sum√©
        const summary = document.createElement('div');
        const allPassed = passedTests === totalTests;
        summary.className = `summary ${allPassed ? 'pass' : 'fail'}`;
        summary.innerHTML = `
            <strong>R√©sum√© des tests : ${passedTests}/${totalTests} r√©ussis (${Math.round(passedTests/totalTests*100)}%)</strong><br>
            ${allPassed ? '‚úÖ Tous les tests sont pass√©s ! La cat√©gorisation fonctionne correctement.' : '‚ùå Certains tests ont √©chou√©. V√©rifiez la logique de cat√©gorisation.'}
        `;
        results.insertBefore(summary, results.firstChild);
    </script>
</body>
</html>
